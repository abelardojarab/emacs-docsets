{
  "source": "doc/api/crypto.md",
  "modules": [
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>The <code>crypto</code> module provides cryptographic functionality that includes a set of\nwrappers for OpenSSL&#39;s hash, HMAC, cipher, decipher, sign and verify functions.</p>\n<p>Use <code>require(&#39;crypto&#39;)</code> to access this module.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\n\nconst secret = &#39;abcdefg&#39;;\nconst hash = crypto.createHmac(&#39;sha256&#39;, secret)\n                   .update(&#39;I love cupcakes&#39;)\n                   .digest(&#39;hex&#39;);\nconsole.log(hash);\n// Prints:\n//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "Determining if crypto support is unavailable",
          "name": "determining_if_crypto_support_is_unavailable",
          "desc": "<p>It is possible for Node.js to be built without including support for the\n<code>crypto</code> module. In such cases, calling <code>require(&#39;crypto&#39;)</code> will result in an\nerror being thrown.</p>\n<pre><code class=\"lang-js\">var crypto;\ntry {\n  crypto = require(&#39;crypto&#39;);\n} catch (err) {\n  console.log(&#39;crypto support is disabled!&#39;);\n}\n</code></pre>\n",
          "type": "module",
          "displayName": "Determining if crypto support is unavailable"
        },
        {
          "textRaw": "`crypto` module methods and properties",
          "name": "`crypto`_module_methods_and_properties",
          "properties": [
            {
              "textRaw": "crypto.constants",
              "name": "constants",
              "meta": {
                "added": [
                  "v6.3.0"
                ]
              },
              "desc": "<p>Returns an object containing commonly used constants for crypto and security\nrelated operations. The specific constants currently defined are described in\n<a href=\"#crypto_crypto_constants_1\">Crypto Constants</a>.</p>\n"
            },
            {
              "textRaw": "crypto.DEFAULT_ENCODING",
              "name": "DEFAULT_ENCODING",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>The default encoding to use for functions that can take either strings\nor <a href=\"buffer.html\">buffers</a>. The default value is <code>&#39;buffer&#39;</code>, which makes methods\ndefault to <a href=\"buffer.html\"><code>Buffer</code></a> objects.</p>\n<p>The <code>crypto.DEFAULT_ENCODING</code> mechanism is provided for backwards compatibility\nwith legacy programs that expect <code>&#39;latin1&#39;</code> to be the default encoding.</p>\n<p>New applications should expect the default to be <code>&#39;buffer&#39;</code>. This property may\nbecome deprecated in a future Node.js release.</p>\n"
            },
            {
              "textRaw": "crypto.fips",
              "name": "fips",
              "meta": {
                "added": [
                  "v6.0.0"
                ]
              },
              "desc": "<p>Property for checking and controlling whether a FIPS compliant crypto provider is\ncurrently in use. Setting to true requires a FIPS build of Node.js.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "crypto.createCipher(algorithm, password)",
              "type": "method",
              "name": "createCipher",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Creates and returns a <code>Cipher</code> object that uses the given <code>algorithm</code> and\n<code>password</code>.</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>password</code> is used to derive the cipher key and initialization vector (IV).\nThe value must be either a <code>&#39;latin1&#39;</code> encoded string or a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>The implementation of <code>crypto.createCipher()</code> derives keys using the OpenSSL\nfunction <a href=\"https://www.openssl.org/docs/man1.0.2/crypto/EVP_BytesToKey.html\"><code>EVP_BytesToKey</code></a> with the digest algorithm set to MD5, one\niteration, and no salt. The lack of salt allows dictionary attacks as the same\npassword always creates the same key. The low iteration count and\nnon-cryptographically secure hash algorithm allow passwords to be tested very\nrapidly.</p>\n<p>In line with OpenSSL&#39;s recommendation to use pbkdf2 instead of\n<a href=\"https://www.openssl.org/docs/man1.0.2/crypto/EVP_BytesToKey.html\"><code>EVP_BytesToKey</code></a> it is recommended that developers derive a key and IV on\ntheir own using <a href=\"#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback\"><code>crypto.pbkdf2()</code></a> and to use <a href=\"#crypto_crypto_createcipheriv_algorithm_key_iv\"><code>crypto.createCipheriv()</code></a>\nto create the <code>Cipher</code> object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "password"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
              "type": "method",
              "name": "createCipheriv",
              "desc": "<p>Creates and returns a <code>Cipher</code> object, with the given <code>algorithm</code>, <code>key</code> and\ninitialization vector (<code>iv</code>).</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an\n<a href=\"https://en.wikipedia.org/wiki/Initialization_vector\">initialization vector</a>. Both arguments must be <code>&#39;utf8&#39;</code> encoded strings or\n<a href=\"buffer.html\">buffers</a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    },
                    {
                      "name": "iv"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createCredentials(details)",
              "type": "method",
              "name": "createCredentials",
              "meta": {
                "added": [
                  "v0.1.92"
                ],
                "deprecated": [
                  "v0.11.13"
                ]
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`tls.createSecureContext()`][] instead.",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`details` {Object} Identical to [`tls.createSecureContext()`][]. ",
                      "name": "details",
                      "type": "Object",
                      "desc": "Identical to [`tls.createSecureContext()`][]."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "details"
                    }
                  ]
                }
              ],
              "desc": "<p>The <code>crypto.createCredentials()</code> method is a deprecated function for creating\nand returning a <code>tls.SecureContext</code>. It should not be used. Replace it with\n<a href=\"tls.html#tls_tls_createsecurecontext_options\"><code>tls.createSecureContext()</code></a> which has the exact same arguments and return\nvalue.</p>\n<p>Returns a <code>tls.SecureContext</code>, as-if <a href=\"tls.html#tls_tls_createsecurecontext_options\"><code>tls.createSecureContext()</code></a> had been\ncalled.</p>\n"
            },
            {
              "textRaw": "crypto.createDecipher(algorithm, password)",
              "type": "method",
              "name": "createDecipher",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code> and\n<code>password</code> (key).</p>\n<p>The implementation of <code>crypto.createDecipher()</code> derives keys using the OpenSSL\nfunction <a href=\"https://www.openssl.org/docs/man1.0.2/crypto/EVP_BytesToKey.html\"><code>EVP_BytesToKey</code></a> with the digest algorithm set to MD5, one\niteration, and no salt. The lack of salt allows dictionary attacks as the same\npassword always creates the same key. The low iteration count and\nnon-cryptographically secure hash algorithm allow passwords to be tested very\nrapidly.</p>\n<p>In line with OpenSSL&#39;s recommendation to use pbkdf2 instead of\n<a href=\"https://www.openssl.org/docs/man1.0.2/crypto/EVP_BytesToKey.html\"><code>EVP_BytesToKey</code></a> it is recommended that developers derive a key and IV on\ntheir own using <a href=\"#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback\"><code>crypto.pbkdf2()</code></a> and to use <a href=\"#crypto_crypto_createdecipheriv_algorithm_key_iv\"><code>crypto.createDecipheriv()</code></a>\nto create the <code>Decipher</code> object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "password"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
              "type": "method",
              "name": "createDecipheriv",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code>, <code>key</code>\nand initialization vector (<code>iv</code>).</p>\n<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On\nrecent OpenSSL releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.</p>\n<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an\n<a href=\"https://en.wikipedia.org/wiki/Initialization_vector\">initialization vector</a>. Both arguments must be <code>&#39;utf8&#39;</code> encoded strings or\n<a href=\"buffer.html\">buffers</a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    },
                    {
                      "name": "iv"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])",
              "type": "method",
              "name": "createDiffieHellman",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>Creates a <code>DiffieHellman</code> key exchange object using the supplied <code>prime</code> and an\noptional specific <code>generator</code>.</p>\n<p>The <code>generator</code> argument can be a number, string, or <a href=\"buffer.html\"><code>Buffer</code></a>. If\n<code>generator</code> is not specified, the value <code>2</code> is used.</p>\n<p>The <code>prime_encoding</code> and <code>generator_encoding</code> arguments can be <code>&#39;latin1&#39;</code>,\n<code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>.</p>\n<p>If <code>prime_encoding</code> is specified, <code>prime</code> is expected to be a string; otherwise\na <a href=\"buffer.html\"><code>Buffer</code></a> is expected.</p>\n<p>If <code>generator_encoding</code> is specified, <code>generator</code> is expected to be a string;\notherwise either a number or <a href=\"buffer.html\"><code>Buffer</code></a> is expected.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prime"
                    },
                    {
                      "name": "prime_encoding",
                      "optional": true
                    },
                    {
                      "name": "generator",
                      "optional": true
                    },
                    {
                      "name": "generator_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createDiffieHellman(prime_length[, generator])",
              "type": "method",
              "name": "createDiffieHellman",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Creates a <code>DiffieHellman</code> key exchange object and generates a prime of\n<code>prime_length</code> bits using an optional specific numeric <code>generator</code>.\nIf <code>generator</code> is not specified, the value <code>2</code> is used.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prime_length"
                    },
                    {
                      "name": "generator",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createECDH(curve_name)",
              "type": "method",
              "name": "createECDH",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Creates an Elliptic Curve Diffie-Hellman (<code>ECDH</code>) key exchange object using a\npredefined curve specified by the <code>curve_name</code> string. Use\n<a href=\"#crypto_crypto_getcurves\"><code>crypto.getCurves()</code></a> to obtain a list of available curve names. On recent\nOpenSSL releases, <code>openssl ecparam -list_curves</code> will also display the name\nand description of each available elliptic curve.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "curve_name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createHash(algorithm)",
              "type": "method",
              "name": "createHash",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Creates and returns a <code>Hash</code> object that can be used to generate hash digests\nusing the given <code>algorithm</code>.</p>\n<p>The <code>algorithm</code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&#39;sha256&#39;</code>, <code>&#39;sha512&#39;</code>, etc.\nOn recent releases of OpenSSL, <code>openssl list-message-digest-algorithms</code> will\ndisplay the available digest algorithms.</p>\n<p>Example: generating the sha256 sum of a file</p>\n<pre><code class=\"lang-js\">const filename = process.argv[2];\nconst crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nconst input = fs.createReadStream(filename);\ninput.on(&#39;readable&#39;, () =&gt; {\n  var data = input.read();\n  if (data)\n    hash.update(data);\n  else {\n    console.log(`${hash.digest(&#39;hex&#39;)} ${filename}`);\n  }\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createHmac(algorithm, key)",
              "type": "method",
              "name": "createHmac",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Creates and returns an <code>Hmac</code> object that uses the given <code>algorithm</code> and <code>key</code>.</p>\n<p>The <code>algorithm</code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&#39;sha256&#39;</code>, <code>&#39;sha512&#39;</code>, etc.\nOn recent releases of OpenSSL, <code>openssl list-message-digest-algorithms</code> will\ndisplay the available digest algorithms.</p>\n<p>The <code>key</code> is the HMAC key used to generate the cryptographic HMAC hash.</p>\n<p>Example: generating the sha256 HMAC of a file</p>\n<pre><code class=\"lang-js\">const filename = process.argv[2];\nconst crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nconst input = fs.createReadStream(filename);\ninput.on(&#39;readable&#39;, () =&gt; {\n  var data = input.read();\n  if (data)\n    hmac.update(data);\n  else {\n    console.log(`${hmac.digest(&#39;hex&#39;)} ${filename}`);\n  }\n});\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    },
                    {
                      "name": "key"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createSign(algorithm)",
              "type": "method",
              "name": "createSign",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Creates and returns a <code>Sign</code> object that uses the given <code>algorithm</code>.\nUse <a href=\"#crypto_crypto_gethashes\"><code>crypto.getHashes()</code></a> to obtain an array of names of the available\nsigning algorithms.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.createVerify(algorithm)",
              "type": "method",
              "name": "createVerify",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Creates and returns a <code>Verify</code> object that uses the given algorithm.\nUse <a href=\"#crypto_crypto_gethashes\"><code>crypto.getHashes()</code></a> to obtain an array of names of the available\nsigning algorithms.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "algorithm"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.getCiphers()",
              "type": "method",
              "name": "getCiphers",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>Returns an array with the names of the supported cipher algorithms.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const ciphers = crypto.getCiphers();\nconsole.log(ciphers); // [&#39;aes-128-cbc&#39;, &#39;aes-128-ccm&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.getCurves()",
              "type": "method",
              "name": "getCurves",
              "meta": {
                "added": [
                  "v2.3.0"
                ]
              },
              "desc": "<p>Returns an array with the names of the supported elliptic curves.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const curves = crypto.getCurves();\nconsole.log(curves); // [&#39;secp256k1&#39;, &#39;secp384r1&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.getDiffieHellman(group_name)",
              "type": "method",
              "name": "getDiffieHellman",
              "meta": {
                "added": [
                  "v0.7.5"
                ]
              },
              "desc": "<p>Creates a predefined <code>DiffieHellman</code> key exchange object. The\nsupported groups are: <code>&#39;modp1&#39;</code>, <code>&#39;modp2&#39;</code>, <code>&#39;modp5&#39;</code> (defined in\n<a href=\"https://www.rfc-editor.org/rfc/rfc2412.txt\">RFC 2412</a>, but see <a href=\"#crypto_support_for_weak_or_compromised_algorithms\">Caveats</a>) and <code>&#39;modp14&#39;</code>, <code>&#39;modp15&#39;</code>,\n<code>&#39;modp16&#39;</code>, <code>&#39;modp17&#39;</code>, <code>&#39;modp18&#39;</code> (defined in <a href=\"https://www.rfc-editor.org/rfc/rfc3526.txt\">RFC 3526</a>). The\nreturned object mimics the interface of objects created by\n<a href=\"#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding\"><code>crypto.createDiffieHellman()</code></a>, but will not allow changing\nthe keys (with <a href=\"#crypto_diffiehellman_setpublickey_public_key_encoding\"><code>diffieHellman.setPublicKey()</code></a> for example). The\nadvantage of using this method is that the parties do not have to\ngenerate nor exchange a group modulus beforehand, saving both processor\nand communication time.</p>\n<p>Example (obtaining a shared secret):</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst alice = crypto.getDiffieHellman(&#39;modp14&#39;);\nconst bob = crypto.getDiffieHellman(&#39;modp14&#39;);\n\nalice.generateKeys();\nbob.generateKeys();\n\nconst alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nconst bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "group_name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.getHashes()",
              "type": "method",
              "name": "getHashes",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>Returns an array of the names of the supported hash algorithms,\nsuch as <code>RSA-SHA256</code>.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const hashes = crypto.getHashes();\nconsole.log(hashes); // [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)",
              "type": "method",
              "name": "pbkdf2",
              "meta": {
                "added": [
                  "v0.5.5"
                ]
              },
              "desc": "<p>Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)\nimplementation. A selected HMAC digest algorithm specified by <code>digest</code> is\napplied to derive a key of the requested byte length (<code>keylen</code>) from the\n<code>password</code>, <code>salt</code> and <code>iterations</code>.</p>\n<p>The supplied <code>callback</code> function is called with two arguments: <code>err</code> and\n<code>derivedKey</code>. If an error occurs, <code>err</code> will be set; otherwise <code>err</code> will be\nnull. The successfully generated <code>derivedKey</code> will be passed as a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>The <code>iterations</code> argument must be a number set as high as possible. The\nhigher the number of iterations, the more secure the derived key will be,\nbut will take a longer amount of time to complete.</p>\n<p>The <code>salt</code> should also be as unique as possible. It is recommended that the\nsalts are random and their lengths are greater than 16 bytes. See\n<a href=\"http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf\">NIST SP 800-132</a> for details.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\ncrypto.pbkdf2(&#39;secret&#39;, &#39;salt&#39;, 100000, 512, &#39;sha512&#39;, (err, key) =&gt; {\n  if (err) throw err;\n  console.log(key.toString(&#39;hex&#39;));  // &#39;c5e478d...1469e50&#39;\n});\n</code></pre>\n<p>An array of supported digest functions can be retrieved using\n<a href=\"#crypto_crypto_gethashes\"><code>crypto.getHashes()</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "password"
                    },
                    {
                      "name": "salt"
                    },
                    {
                      "name": "iterations"
                    },
                    {
                      "name": "keylen"
                    },
                    {
                      "name": "digest"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)",
              "type": "method",
              "name": "pbkdf2Sync",
              "meta": {
                "added": [
                  "v0.9.3"
                ]
              },
              "desc": "<p>Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)\nimplementation. A selected HMAC digest algorithm specified by <code>digest</code> is\napplied to derive a key of the requested byte length (<code>keylen</code>) from the\n<code>password</code>, <code>salt</code> and <code>iterations</code>.</p>\n<p>If an error occurs an Error will be thrown, otherwise the derived key will be\nreturned as a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>The <code>iterations</code> argument must be a number set as high as possible. The\nhigher the number of iterations, the more secure the derived key will be,\nbut will take a longer amount of time to complete.</p>\n<p>The <code>salt</code> should also be as unique as possible. It is recommended that the\nsalts are random and their lengths are greater than 16 bytes. See\n<a href=\"http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf\">NIST SP 800-132</a> for details.</p>\n<p>Example:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst key = crypto.pbkdf2Sync(&#39;secret&#39;, &#39;salt&#39;, 100000, 512, &#39;sha512&#39;);\nconsole.log(key.toString(&#39;hex&#39;));  // &#39;c5e478d...1469e50&#39;\n</code></pre>\n<p>An array of supported digest functions can be retrieved using\n<a href=\"#crypto_crypto_gethashes\"><code>crypto.getHashes()</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "password"
                    },
                    {
                      "name": "salt"
                    },
                    {
                      "name": "iterations"
                    },
                    {
                      "name": "keylen"
                    },
                    {
                      "name": "digest"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.privateDecrypt(private_key, buffer)",
              "type": "method",
              "name": "privateDecrypt",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Decrypts <code>buffer</code> with <code>private_key</code>.</p>\n<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.\nIf <code>private_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>crypto.constants.RSA_NO_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>All paddings are defined in <code>crypto.constants</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.timingSafeEqual(a, b)",
              "type": "method",
              "name": "timingSafeEqual",
              "meta": {
                "added": [
                  "v6.6.0"
                ]
              },
              "desc": "<p>Returns true if <code>a</code> is equal to <code>b</code>, without leaking timing information that\nwould allow an attacker to guess one of the values. This is suitable for\ncomparing HMAC digests or secret values like authentication cookies or\n<a href=\"https://www.w3.org/TR/capability-urls/\">capability urls</a>.</p>\n<p><code>a</code> and <code>b</code> must both be <code>Buffer</code>s, and they must have the same length.</p>\n<p><strong>Note</strong>: Use of <code>crypto.timingSafeEqual</code> does not guarantee that the\n<em>surrounding</em> code is timing-safe. Care should be taken to ensure that the\nsurrounding code does not introduce timing vulnerabilities.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "a"
                    },
                    {
                      "name": "b"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.privateEncrypt(private_key, buffer)",
              "type": "method",
              "name": "privateEncrypt",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "desc": "<p>Encrypts <code>buffer</code> with <code>private_key</code>.</p>\n<p><code>private_key</code> can be an object or a string. If <code>private_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_PADDING</code>.\nIf <code>private_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>crypto.constants.RSA_NO_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>All paddings are defined in <code>crypto.constants</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.publicDecrypt(public_key, buffer)",
              "type": "method",
              "name": "publicDecrypt",
              "meta": {
                "added": [
                  "v1.1.0"
                ]
              },
              "desc": "<p>Decrypts <code>buffer</code> with <code>public_key</code>.</p>\n<p><code>public_key</code> can be an object or a string. If <code>public_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_PADDING</code>.\nIf <code>public_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded public key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>crypto.constants.RSA_NO_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>Because RSA public keys can be derived from private keys, a private key may\nbe passed instead of a public key.</p>\n<p>All paddings are defined in <code>crypto.constants</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.publicEncrypt(public_key, buffer)",
              "type": "method",
              "name": "publicEncrypt",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Encrypts <code>buffer</code> with <code>public_key</code>.</p>\n<p><code>public_key</code> can be an object or a string. If <code>public_key</code> is a string, it is\ntreated as the key with no passphrase and will use <code>RSA_PKCS1_OAEP_PADDING</code>.\nIf <code>public_key</code> is an object, it is interpreted as a hash object with the\nkeys:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded public key</li>\n<li><code>passphrase</code> : {String} - Optional passphrase for the private key</li>\n<li><code>padding</code> : An optional padding value, one of the following:<ul>\n<li><code>crypto.constants.RSA_NO_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_PADDING</code></li>\n<li><code>crypto.constants.RSA_PKCS1_OAEP_PADDING</code></li>\n</ul>\n</li>\n</ul>\n<p>Because RSA public keys can be derived from private keys, a private key may\nbe passed instead of a public key.</p>\n<p>All paddings are defined in <code>crypto.constants</code>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.randomBytes(size[, callback])",
              "type": "method",
              "name": "randomBytes",
              "meta": {
                "added": [
                  "v0.5.8"
                ]
              },
              "desc": "<p>Generates cryptographically strong pseudo-random data. The <code>size</code> argument\nis a number indicating the number of bytes to generate.</p>\n<p>If a <code>callback</code> function is provided, the bytes are generated asynchronously\nand the <code>callback</code> function is invoked with two arguments: <code>err</code> and <code>buf</code>.\nIf an error occurs, <code>err</code> will be an Error object; otherwise it is null. The\n<code>buf</code> argument is a <a href=\"buffer.html\"><code>Buffer</code></a> containing the generated bytes.</p>\n<pre><code class=\"lang-js\">// Asynchronous\nconst crypto = require(&#39;crypto&#39;);\ncrypto.randomBytes(256, (err, buf) =&gt; {\n  if (err) throw err;\n  console.log(`${buf.length} bytes of random data: ${buf.toString(&#39;hex&#39;)}`);\n});\n</code></pre>\n<p>If the <code>callback</code> function is not provided, the random bytes are generated\nsynchronously and returned as a <a href=\"buffer.html\"><code>Buffer</code></a>. An error will be thrown if\nthere is a problem generating the bytes.</p>\n<pre><code class=\"lang-js\">// Synchronous\nconst buf = crypto.randomBytes(256);\nconsole.log(\n  `${buf.length} bytes of random data: ${buf.toString(&#39;hex&#39;)}`);\n</code></pre>\n<p>The <code>crypto.randomBytes()</code> method will block until there is sufficient entropy.\nThis should normally never take longer than a few milliseconds. The only time\nwhen generating the random bytes may conceivably block for a longer period of\ntime is right after boot, when the whole system is still low on entropy.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "crypto.setEngine(engine[, flags])",
              "type": "method",
              "name": "setEngine",
              "meta": {
                "added": [
                  "v0.11.11"
                ]
              },
              "desc": "<p>Load and set the <code>engine</code> for some or all OpenSSL functions (selected by flags).</p>\n<p><code>engine</code> could be either an id or a path to the engine&#39;s shared library.</p>\n<p>The optional <code>flags</code> argument uses <code>ENGINE_METHOD_ALL</code> by default. The <code>flags</code>\nis a bit field taking one of or a mix of the following flags (defined in\n<code>crypto.constants</code>):</p>\n<ul>\n<li><code>crypto.constants.ENGINE_METHOD_RSA</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_DSA</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_DH</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_RAND</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_ECDH</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_ECDSA</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_CIPHERS</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_DIGESTS</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_STORE</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_PKEY_METHS</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_ALL</code></li>\n<li><code>crypto.constants.ENGINE_METHOD_NONE</code></li>\n</ul>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "engine"
                    },
                    {
                      "name": "flags",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "`crypto` module methods and properties"
        },
        {
          "textRaw": "Notes",
          "name": "notes",
          "modules": [
            {
              "textRaw": "Legacy Streams API (pre Node.js v0.10)",
              "name": "legacy_streams_api_(pre_node.js_v0.10)",
              "desc": "<p>The Crypto module was added to Node.js before there was the concept of a\nunified Stream API, and before there were <a href=\"buffer.html\"><code>Buffer</code></a> objects for handling\nbinary data. As such, the many of the <code>crypto</code> defined classes have methods not\ntypically found on other Node.js classes that implement the <a href=\"stream.html\">streams</a>\nAPI (e.g. <code>update()</code>, <code>final()</code>, or <code>digest()</code>). Also, many methods accepted\nand returned <code>&#39;latin1&#39;</code> encoded strings by default rather than Buffers. This\ndefault was changed after Node.js v0.8 to use <a href=\"buffer.html\"><code>Buffer</code></a> objects by default\ninstead.</p>\n",
              "type": "module",
              "displayName": "Legacy Streams API (pre Node.js v0.10)"
            },
            {
              "textRaw": "Recent ECDH Changes",
              "name": "recent_ecdh_changes",
              "desc": "<p>Usage of <code>ECDH</code> with non-dynamically generated key pairs has been simplified.\nNow, <a href=\"#crypto_ecdh_setprivatekey_private_key_encoding\"><code>ecdh.setPrivateKey()</code></a> can be called with a preselected private key\nand the associated public point (key) will be computed and stored in the object.\nThis allows code to only store and provide the private part of the EC key pair.\n<a href=\"#crypto_ecdh_setprivatekey_private_key_encoding\"><code>ecdh.setPrivateKey()</code></a> now also validates that the private key is valid for\nthe selected curve.</p>\n<p>The <a href=\"#crypto_ecdh_setpublickey_public_key_encoding\"><code>ecdh.setPublicKey()</code></a> method is now deprecated as its inclusion in the\nAPI is not useful. Either a previously stored private key should be set, which\nautomatically generates the associated public key, or <a href=\"#crypto_ecdh_generatekeys_encoding_format\"><code>ecdh.generateKeys()</code></a>\nshould be called. The main drawback of using <a href=\"#crypto_ecdh_setpublickey_public_key_encoding\"><code>ecdh.setPublicKey()</code></a> is that\nit can be used to put the ECDH key pair into an inconsistent state.</p>\n",
              "type": "module",
              "displayName": "Recent ECDH Changes"
            },
            {
              "textRaw": "Support for weak or compromised algorithms",
              "name": "support_for_weak_or_compromised_algorithms",
              "desc": "<p>The <code>crypto</code> module still supports some algorithms which are already\ncompromised and are not currently recommended for use. The API also allows\nthe use of ciphers and hashes with a small key size that are considered to be\ntoo weak for safe use.</p>\n<p>Users should take full responsibility for selecting the crypto\nalgorithm and key size according to their security requirements.</p>\n<p>Based on the recommendations of <a href=\"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\">NIST SP 800-131A</a>:</p>\n<ul>\n<li>MD5 and SHA-1 are no longer acceptable where collision resistance is\nrequired such as digital signatures.</li>\n<li>The key used with RSA, DSA and DH algorithms is recommended to have\nat least 2048 bits and that of the curve of ECDSA and ECDH at least\n224 bits, to be safe to use for several years.</li>\n<li>The DH groups of <code>modp1</code>, <code>modp2</code> and <code>modp5</code> have a key size\nsmaller than 2048 bits and are not recommended.</li>\n</ul>\n<p>See the reference for other recommendations and details.</p>\n",
              "type": "module",
              "displayName": "Support for weak or compromised algorithms"
            }
          ],
          "type": "module",
          "displayName": "Notes"
        },
        {
          "textRaw": "Crypto Constants",
          "name": "crypto_constants",
          "desc": "<p>The following constants exported by <code>crypto.constants</code> apply to various uses of\nthe <code>crypto</code>, <code>tls</code>, and <code>https</code> modules and are generally specific to OpenSSL.</p>\n",
          "modules": [
            {
              "textRaw": "OpenSSL Options",
              "name": "openssl_options",
              "desc": "<table>\n  <tr>\n    <th>Constant</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_ALL</code></td>\n    <td>Applies multiple bug workarounds within OpenSSL. See\n    <a href=\"https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html\">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a> for\n    detail.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION</code></td>\n    <td>Allows legacy insecure renegotiation between OpenSSL and unpatched\n    clients or servers. See\n    <a href=\"https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html\">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a>.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_CIPHER_SERVER_PREFERENCE</code></td>\n    <td>Attempts to use the server&#39;s preferences instead of the client&#39;s when\n    selecting a cipher. Behaviour depends on protocol version. See\n    <a href=\"https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html\">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a>.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_CISCO_ANYCONNECT</code></td>\n    <td>Instructs OpenSSL to use Cisco&#39;s &quot;speshul&quot; version of DTLS_BAD_VER.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_COOKIE_EXCHANGE</code></td>\n    <td>Instructs OpenSSL to turn on cookie exchange.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_CRYPTOPRO_TLSEXT_BUG</code></td>\n    <td>Instructs OpenSSL to add server-hello extension from an early version\n    of the cryptopro draft.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS</code></td>\n    <td>Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability\n    workaround added in OpenSSL 0.9.6d.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_EPHEMERAL_RSA</code></td>\n    <td>Instructs OpenSSL to always use the tmp_rsa key when performing RSA\n    operations.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_LEGACY_SERVER_CONNECT</code></td>\n    <td>Allows initial connection to servers that do not support RI.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_MICROSOFT_SESS_ID_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_MSIE_SSLV2_RSA_PADDING</code></td>\n    <td>Instructs OpenSSL to disable the workaround for a man-in-the-middle\n    protocol-version vulnerability in the SSL 2.0 server implementation.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NETSCAPE_CA_DN_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NETSCAPE_CHALLENGE_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_COMPRESSION</code></td>\n    <td>Instructs OpenSSL to disable support for SSL/TLS compression.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_QUERY_MTU</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION</code></td>\n    <td>Instructs OpenSSL to always start a new session when performing\n    renegotiation.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_SSLv2</code></td>\n    <td>Instructs OpenSSL to turn off SSL v2</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_SSLv3</code></td>\n    <td>Instructs OpenSSL to turn off SSL v3</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_TICKET</code></td>\n    <td>Instructs OpenSSL to disable use of RFC4507bis tickets.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_TLSv1</code></td>\n    <td>Instructs OpenSSL to turn off TLS v1</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_TLSv1_1</code></td>\n    <td>Instructs OpenSSL to turn off TLS v1.1</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_NO_TLSv1_2</code></td>\n    <td>Instructs OpenSSL to turn off TLS v1.2</td>\n  </tr>\n    <td><code>SSL_OP_PKCS1_CHECK_1</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_PKCS1_CHECK_2</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_SINGLE_DH_USE</code></td>\n    <td>Instructs OpenSSL to always create a new key when using\n    temporary/ephemeral DH parameters.</td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_SINGLE_ECDH_USE</code></td>\n    <td>Instructs OpenSSL to always create a new key when using\n    temporary/ephemeral ECDH parameters.</td>\n  </tr>\n    <td><code>SSL_OP_SSLEAY_080_CLIENT_DH_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_TLS_BLOCK_PADDING_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_TLS_D5_BUG</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>SSL_OP_TLS_ROLLBACK_BUG</code></td>\n    <td>Instructs OpenSSL to disable version rollback attack detection.</td>\n  </tr>\n</table>\n\n",
              "type": "module",
              "displayName": "OpenSSL Options"
            },
            {
              "textRaw": "OpenSSL Engine Constants",
              "name": "openssl_engine_constants",
              "desc": "<table>\n  <tr>\n    <th>Constant</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_RSA</code></td>\n    <td>Limit engine usage to RSA</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_DSA</code></td>\n    <td>Limit engine usage to DSA</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_DH</code></td>\n    <td>Limit engine usage to DH</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_RAND</code></td>\n    <td>Limit engine usage to RAND</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_ECDH</code></td>\n    <td>Limit engine usage to ECDH</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_ECDSA</code></td>\n    <td>Limit engine usage to ECDSA</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_CIPHERS</code></td>\n    <td>Limit engine usage to CIPHERS</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_DIGESTS</code></td>\n    <td>Limit engine usage to DIGESTS</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_STORE</code></td>\n    <td>Limit engine usage to STORE</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_PKEY_METHS</code></td>\n    <td>Limit engine usage to PKEY_METHDS</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_PKEY_ASN1_METHS</code></td>\n    <td>Limit engine usage to PKEY_ASN1_METHS</td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_ALL</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>ENGINE_METHOD_NONE</code></td>\n    <td></td>\n  </tr>\n</table>\n\n",
              "type": "module",
              "displayName": "OpenSSL Engine Constants"
            },
            {
              "textRaw": "Other OpenSSL Constants",
              "name": "other_openssl_constants",
              "desc": "<table>\n  <tr>\n    <th>Constant</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>DH_CHECK_P_NOT_SAFE_PRIME</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>DH_CHECK_P_NOT_PRIME</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>DH_UNABLE_TO_CHECK_GENERATOR</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>DH_NOT_SUITABLE_GENERATOR</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>NPN_ENABLED</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>ALPN_ENABLED</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_PKCS1_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_SSLV23_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_NO_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_PKCS1_OAEP_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_X931_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>RSA_PKCS1_PSS_PADDING</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>POINT_CONVERSION_COMPRESSED</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>POINT_CONVERSION_UNCOMPRESSED</code></td>\n    <td></td>\n  </tr>\n  <tr>\n    <td><code>POINT_CONVERSION_HYBRID</code></td>\n    <td></td>\n  </tr>\n</table>\n\n",
              "type": "module",
              "displayName": "Other OpenSSL Constants"
            },
            {
              "textRaw": "Node.js Crypto Constants",
              "name": "node.js_crypto_constants",
              "desc": "<table>\n  <tr>\n    <th>Constant</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>defaultCoreCipherList</code></td>\n    <td>Specifies the built-in default cipher list used by Node.js.</td>\n  </tr>\n  <tr>\n    <td><code>defaultCipherList</code></td>\n    <td>Specifies the active default cipher list used by the current Node.js\n    process.</td>\n  </tr>\n</table>\n\n\n",
              "type": "module",
              "displayName": "Node.js Crypto Constants"
            }
          ],
          "type": "module",
          "displayName": "Crypto Constants"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Certificate",
          "type": "class",
          "name": "Certificate",
          "meta": {
            "added": [
              "v0.11.8"
            ]
          },
          "desc": "<p>SPKAC is a Certificate Signing Request mechanism originally implemented by\nNetscape and now specified formally as part of <a href=\"http://www.w3.org/TR/html5/forms.html#the-keygen-element\">HTML5&#39;s <code>keygen</code> element</a>.</p>\n<p>The <code>crypto</code> module provides the <code>Certificate</code> class for working with SPKAC\ndata. The most common usage is handling output generated by the HTML5\n<code>&lt;keygen&gt;</code> element. Node.js uses <a href=\"https://www.openssl.org/docs/man1.0.2/apps/spkac.html\">OpenSSL&#39;s SPKAC implementation</a> internally.</p>\n",
          "methods": [
            {
              "textRaw": "new crypto.Certificate()",
              "type": "method",
              "name": "Certificate",
              "desc": "<p>Instances of the <code>Certificate</code> class can be created using the <code>new</code> keyword\nor by calling <code>crypto.Certificate()</code> as a function:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\n\nconst cert1 = new crypto.Certificate();\nconst cert2 = crypto.Certificate();\n</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "certificate.exportChallenge(spkac)",
              "type": "method",
              "name": "exportChallenge",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>The <code>spkac</code> data structure includes a public key and a challenge. The\n<code>certificate.exportChallenge()</code> returns the challenge component in the\nform of a Node.js <a href=\"buffer.html\"><code>Buffer</code></a>. The <code>spkac</code> argument can be either a string\nor a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconst challenge = cert.exportChallenge(spkac);\nconsole.log(challenge.toString(&#39;utf8&#39;));\n// Prints: the challenge as a UTF8 string\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "certificate.exportPublicKey(spkac)",
              "type": "method",
              "name": "exportPublicKey",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>The <code>spkac</code> data structure includes a public key and a challenge. The\n<code>certificate.exportPublicKey()</code> returns the public key component in the\nform of a Node.js <a href=\"buffer.html\"><code>Buffer</code></a>. The <code>spkac</code> argument can be either a string\nor a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconst publicKey = cert.exportPublicKey(spkac);\nconsole.log(publicKey);\n// Prints: the public key as &lt;Buffer ...&gt;\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "certificate.verifySpkac(spkac)",
              "type": "method",
              "name": "verifySpkac",
              "meta": {
                "added": [
                  "v0.11.8"
                ]
              },
              "desc": "<p>Returns <code>true</code> if the given <code>spkac</code> data structure is valid, <code>false</code> otherwise.\nThe <code>spkac</code> argument must be a Node.js <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<pre><code class=\"lang-js\">const cert = require(&#39;crypto&#39;).Certificate();\nconst spkac = getSpkacSomehow();\nconsole.log(cert.verifySpkac(Buffer.from(spkac)));\n// Prints: true or false\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "spkac"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "meta": {
            "added": [
              "v0.1.94"
            ]
          },
          "desc": "<p>Instances of the <code>Cipher</code> class are used to encrypt data. The class can be\nused in one of two ways:</p>\n<ul>\n<li>As a <a href=\"stream.html\">stream</a> that is both readable and writable, where plain unencrypted\ndata is written to produce encrypted data on the readable side, or</li>\n<li>Using the <a href=\"#crypto_cipher_update_data_input_encoding_output_encoding\"><code>cipher.update()</code></a> and <a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> methods to produce\nthe encrypted data.</li>\n</ul>\n<p>The <a href=\"#crypto_crypto_createcipher_algorithm_password\"><code>crypto.createCipher()</code></a> or <a href=\"#crypto_crypto_createcipheriv_algorithm_key_iv\"><code>crypto.createCipheriv()</code></a> methods are\nused to create <code>Cipher</code> instances. <code>Cipher</code> objects are not to be created\ndirectly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Cipher</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = &#39;&#39;;\ncipher.on(&#39;readable&#39;, () =&gt; {\n  var data = cipher.read();\n  if (data)\n    encrypted += data.toString(&#39;hex&#39;);\n});\ncipher.on(&#39;end&#39;, () =&gt; {\n  console.log(encrypted);\n  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n});\n\ncipher.write(&#39;some clear text data&#39;);\ncipher.end();\n</code></pre>\n<p>Example: Using <code>Cipher</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\nconst output = fs.createWriteStream(&#39;test.enc&#39;);\n\ninput.pipe(cipher).pipe(output);\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_cipher_update_data_input_encoding_output_encoding\"><code>cipher.update()</code></a> and <a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst cipher = crypto.createCipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = cipher.update(&#39;some clear text data&#39;, &#39;utf8&#39;, &#39;hex&#39;);\nencrypted += cipher.final(&#39;hex&#39;);\nconsole.log(encrypted);\n// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Returns any remaining enciphered contents. If <code>output_encoding</code>\nparameter is one of <code>&#39;latin1&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>, a string is returned.\nIf an <code>output_encoding</code> is not provided, a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n<p>Once the <code>cipher.final()</code> method has been called, the <code>Cipher</code> object can no\nlonger be used to encrypt data. Attempts to call <code>cipher.final()</code> more than\nonce will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAAD(buffer)",
              "type": "method",
              "name": "setAAD",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>cipher.setAAD()</code> method sets the value used for the\n<em>additional authenticated data</em> (AAD) input parameter.</p>\n<p>Returns <code>this</code> for method chaining.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.getAuthTag()",
              "type": "method",
              "name": "getAuthTag",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>cipher.getAuthTag()</code> method returns a <a href=\"buffer.html\"><code>Buffer</code></a> containing\nthe <em>authentication tag</em> that has been computed from the given data.</p>\n<p>The <code>cipher.getAuthTag()</code> method should only be called after encryption has\nbeen completed using the <a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> method.</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "meta": {
                "added": [
                  "v0.7.1"
                ]
              },
              "desc": "<p>When using block encryption algorithms, the <code>Cipher</code> class will automatically\nadd padding to the input data to the appropriate block size. To disable the\ndefault padding call <code>cipher.setAutoPadding(false)</code>.</p>\n<p>When <code>auto_padding</code> is <code>false</code>, the length of the entire input data must be a\nmultiple of the cipher&#39;s block size or <a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> will throw an Error.\nDisabling automatic padding is useful for non-standard padding, for instance\nusing <code>0x0</code> instead of PKCS padding.</p>\n<p>The <code>cipher.setAutoPadding()</code> method must be called before <a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a>.</p>\n<p>Returns <code>this</code> for method chaining.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.update(data[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Updates the cipher with <code>data</code>. If the <code>input_encoding</code> argument is given,\nits value must be one of <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code>, or <code>&#39;latin1&#39;</code> and the <code>data</code>\nargument is a string using the specified encoding. If the <code>input_encoding</code>\nargument is not given, <code>data</code> must be a <a href=\"buffer.html\"><code>Buffer</code></a>. If <code>data</code> is a\n<a href=\"buffer.html\"><code>Buffer</code></a> then <code>input_encoding</code> is ignored.</p>\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\ndata, and can be <code>&#39;latin1&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>. If the <code>output_encoding</code>\nis specified, a string using the specified encoding is returned. If no\n<code>output_encoding</code> is provided, a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n<p>The <code>cipher.update()</code> method can be called multiple times with new data until\n<a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> is called. Calling <code>cipher.update()</code> after\n<a href=\"#crypto_cipher_final_output_encoding\"><code>cipher.final()</code></a> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "meta": {
            "added": [
              "v0.1.94"
            ]
          },
          "desc": "<p>Instances of the <code>Decipher</code> class are used to decrypt data. The class can be\nused in one of two ways:</p>\n<ul>\n<li>As a <a href=\"stream.html\">stream</a> that is both readable and writable, where plain encrypted\ndata is written to produce unencrypted data on the readable side, or</li>\n<li>Using the <a href=\"#crypto_decipher_update_data_input_encoding_output_encoding\"><code>decipher.update()</code></a> and <a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> methods to\nproduce the unencrypted data.</li>\n</ul>\n<p>The <a href=\"#crypto_crypto_createdecipher_algorithm_password\"><code>crypto.createDecipher()</code></a> or <a href=\"#crypto_crypto_createdecipheriv_algorithm_key_iv\"><code>crypto.createDecipheriv()</code></a> methods are\nused to create <code>Decipher</code> instances. <code>Decipher</code> objects are not to be created\ndirectly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Decipher</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar decrypted = &#39;&#39;;\ndecipher.on(&#39;readable&#39;, () =&gt; {\n  var data = decipher.read();\n  if (data)\n    decrypted += data.toString(&#39;utf8&#39;);\n});\ndecipher.on(&#39;end&#39;, () =&gt; {\n  console.log(decrypted);\n  // Prints: some clear text data\n});\n\nvar encrypted = &#39;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#39;;\ndecipher.write(encrypted, &#39;hex&#39;);\ndecipher.end();\n</code></pre>\n<p>Example: Using <code>Decipher</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nconst input = fs.createReadStream(&#39;test.enc&#39;);\nconst output = fs.createWriteStream(&#39;test.js&#39;);\n\ninput.pipe(decipher).pipe(output);\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_decipher_update_data_input_encoding_output_encoding\"><code>decipher.update()</code></a> and <a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst decipher = crypto.createDecipher(&#39;aes192&#39;, &#39;a password&#39;);\n\nvar encrypted = &#39;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#39;;\nvar decrypted = decipher.update(encrypted, &#39;hex&#39;, &#39;utf8&#39;);\ndecrypted += decipher.final(&#39;utf8&#39;);\nconsole.log(decrypted);\n// Prints: some clear text data\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Returns any remaining deciphered contents. If <code>output_encoding</code>\nparameter is one of <code>&#39;latin1&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;utf8&#39;</code>, a string is returned.\nIf an <code>output_encoding</code> is not provided, a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n<p>Once the <code>decipher.final()</code> method has been called, the <code>Decipher</code> object can\nno longer be used to decrypt data. Attempts to call <code>decipher.final()</code> more\nthan once will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAAD(buffer)",
              "type": "method",
              "name": "setAAD",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>decipher.setAAD()</code> method sets the value used for the\n<em>additional authenticated data</em> (AAD) input parameter.</p>\n<p>Returns <code>this</code> for method chaining.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAuthTag(buffer)",
              "type": "method",
              "name": "setAuthTag",
              "meta": {
                "added": [
                  "v1.0.0"
                ]
              },
              "desc": "<p>When using an authenticated encryption mode (only <code>GCM</code> is currently\nsupported), the <code>decipher.setAuthTag()</code> method is used to pass in the\nreceived <em>authentication tag</em>. If no tag is provided, or if the cipher text\nhas been tampered with, <a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> with throw, indicating that the\ncipher text should be discarded due to failed authentication.</p>\n<p>Returns <code>this</code> for method chaining.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "meta": {
                "added": [
                  "v0.7.1"
                ]
              },
              "desc": "<p>When data has been encrypted without standard block padding, calling\n<code>decipher.setAutoPadding(false)</code> will disable automatic padding to prevent\n<a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> from checking for and removing padding.</p>\n<p>Turning auto padding off will only work if the input data&#39;s length is a\nmultiple of the ciphers block size.</p>\n<p>The <code>decipher.setAutoPadding()</code> method must be called before\n<a href=\"#crypto_decipher_update_data_input_encoding_output_encoding\"><code>decipher.update()</code></a>.</p>\n<p>Returns <code>this</code> for method chaining.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.update(data[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Updates the decipher with <code>data</code>. If the <code>input_encoding</code> argument is given,\nits value must be one of <code>&#39;latin1&#39;</code>, <code>&#39;base64&#39;</code>, or <code>&#39;hex&#39;</code> and the <code>data</code>\nargument is a string using the specified encoding. If the <code>input_encoding</code>\nargument is not given, <code>data</code> must be a <a href=\"buffer.html\"><code>Buffer</code></a>. If <code>data</code> is a\n<a href=\"buffer.html\"><code>Buffer</code></a> then <code>input_encoding</code> is ignored.</p>\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\ndata, and can be <code>&#39;latin1&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;utf8&#39;</code>. If the <code>output_encoding</code>\nis specified, a string using the specified encoding is returned. If no\n<code>output_encoding</code> is provided, a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n<p>The <code>decipher.update()</code> method can be called multiple times with new data until\n<a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> is called. Calling <code>decipher.update()</code> after\n<a href=\"#crypto_decipher_final_output_encoding\"><code>decipher.final()</code></a> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "meta": {
            "added": [
              "v0.5.0"
            ]
          },
          "desc": "<p>The <code>DiffieHellman</code> class is a utility for creating Diffie-Hellman key\nexchanges.</p>\n<p>Instances of the <code>DiffieHellman</code> class can be created using the\n<a href=\"#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding\"><code>crypto.createDiffieHellman()</code></a> function.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst assert = require(&#39;assert&#39;);\n\n// Generate Alice&#39;s keys...\nconst alice = crypto.createDiffieHellman(2048);\nconst alice_key = alice.generateKeys();\n\n// Generate Bob&#39;s keys...\nconst bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());\nconst bob_key = bob.generateKeys();\n\n// Exchange and generate the secret...\nconst alice_secret = alice.computeSecret(bob_key);\nconst bob_secret = bob.computeSecret(alice_key);\n\n// OK\nassert.equal(alice_secret.toString(&#39;hex&#39;), bob_secret.toString(&#39;hex&#39;));\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other\nparty&#39;s public key and returns the computed shared secret. The supplied\nkey is interpreted using the specified <code>input_encoding</code>, and secret is\nencoded using specified <code>output_encoding</code>. Encodings can be\n<code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If the <code>input_encoding</code> is not\nprovided, <code>other_public_key</code> is expected to be a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>If <code>output_encoding</code> is given a string is returned; otherwise, a\n<a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Generates private and public Diffie-Hellman key values, and returns\nthe public key in the specified <code>encoding</code>. This key should be\ntransferred to the other party. Encoding can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>,\nor <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string is returned; otherwise a\n<a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Returns the Diffie-Hellman generator in the specified <code>encoding</code>, which can\nbe <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If  <code>encoding</code> is provided a string is\nreturned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Returns the Diffie-Hellman prime in the specified <code>encoding</code>, which can\nbe <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string is\nreturned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Returns the Diffie-Hellman private key in the specified <code>encoding</code>,\nwhich can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a\nstring is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Returns the Diffie-Hellman public key in the specified <code>encoding</code>, which\ncan be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a\nstring is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(private_key[, encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Sets the Diffie-Hellman private key. If the <code>encoding</code> argument is provided\nand is either <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>, <code>private_key</code> is expected\nto be a string. If no <code>encoding</code> is provided, <code>private_key</code> is expected\nto be a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key[, encoding])",
              "type": "method",
              "name": "setPublicKey",
              "meta": {
                "added": [
                  "v0.5.0"
                ]
              },
              "desc": "<p>Sets the Diffie-Hellman public key. If the <code>encoding</code> argument is provided\nand is either <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>, <code>public_key</code> is expected\nto be a string. If no <code>encoding</code> is provided, <code>public_key</code> is expected\nto be a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "diffieHellman.verifyError",
              "name": "verifyError",
              "meta": {
                "added": [
                  "v0.11.12"
                ]
              },
              "desc": "<p>A bit field containing any warnings and/or errors resulting from a check\nperformed during initialization of the <code>DiffieHellman</code> object.</p>\n<p>The following values are valid for this property (as defined in <code>constants</code>\nmodule):</p>\n<ul>\n<li><code>DH_CHECK_P_NOT_SAFE_PRIME</code></li>\n<li><code>DH_CHECK_P_NOT_PRIME</code></li>\n<li><code>DH_UNABLE_TO_CHECK_GENERATOR</code></li>\n<li><code>DH_NOT_SUITABLE_GENERATOR</code></li>\n</ul>\n"
            }
          ]
        },
        {
          "textRaw": "Class: ECDH",
          "type": "class",
          "name": "ECDH",
          "meta": {
            "added": [
              "v0.11.14"
            ]
          },
          "desc": "<p>The <code>ECDH</code> class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)\nkey exchanges.</p>\n<p>Instances of the <code>ECDH</code> class can be created using the\n<a href=\"#crypto_crypto_createecdh_curve_name\"><code>crypto.createECDH()</code></a> function.</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst assert = require(&#39;assert&#39;);\n\n// Generate Alice&#39;s keys...\nconst alice = crypto.createECDH(&#39;secp521r1&#39;);\nconst alice_key = alice.generateKeys();\n\n// Generate Bob&#39;s keys...\nconst bob = crypto.createECDH(&#39;secp521r1&#39;);\nconst bob_key = bob.generateKeys();\n\n// Exchange and generate the secret...\nconst alice_secret = alice.computeSecret(bob_key);\nconst bob_secret = bob.computeSecret(alice_key);\n\nassert(alice_secret, bob_secret);\n  // OK\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "ecdh.computeSecret(other_public_key[, input_encoding][, output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other\nparty&#39;s public key and returns the computed shared secret. The supplied\nkey is interpreted using specified <code>input_encoding</code>, and the returned secret\nis encoded using the specified <code>output_encoding</code>. Encodings can be\n<code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If the <code>input_encoding</code> is not\nprovided, <code>other_public_key</code> is expected to be a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>If <code>output_encoding</code> is given a string will be returned; otherwise a\n<a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.generateKeys([encoding[, format]])",
              "type": "method",
              "name": "generateKeys",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Generates private and public EC Diffie-Hellman key values, and returns\nthe public key in the specified <code>format</code> and <code>encoding</code>. This key should be\ntransferred to the other party.</p>\n<p>The <code>format</code> argument specifies point encoding and can be <code>&#39;compressed&#39;</code> or\n<code>&#39;uncompressed&#39;</code>. If <code>format</code> is not specified, the point will be returned in\n<code>&#39;uncompressed&#39;</code> format.</p>\n<p>The <code>encoding</code> argument can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If\n<code>encoding</code> is provided a string is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a>\nis returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Returns the EC Diffie-Hellman private key in the specified <code>encoding</code>,\nwhich can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided\na string is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.getPublicKey([encoding[, format]])",
              "type": "method",
              "name": "getPublicKey",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Returns the EC Diffie-Hellman public key in the specified <code>encoding</code> and\n<code>format</code>.</p>\n<p>The <code>format</code> argument specifies point encoding and can be <code>&#39;compressed&#39;</code> or\n<code>&#39;uncompressed&#39;</code>. If <code>format</code> is not specified the point will be returned in\n<code>&#39;uncompressed&#39;</code> format.</p>\n<p>The <code>encoding</code> argument can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If\n<code>encoding</code> is specified, a string is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is\nreturned.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.setPrivateKey(private_key[, encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "meta": {
                "added": [
                  "v0.11.14"
                ]
              },
              "desc": "<p>Sets the EC Diffie-Hellman private key. The <code>encoding</code> can be <code>&#39;latin1&#39;</code>,\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided, <code>private_key</code> is expected\nto be a string; otherwise <code>private_key</code> is expected to be a <a href=\"buffer.html\"><code>Buffer</code></a>. If\n<code>private_key</code> is not valid for the curve specified when the <code>ECDH</code> object was\ncreated, an error is thrown. Upon setting the private key, the associated\npublic point (key) is also generated and set in the ECDH object.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "ecdh.setPublicKey(public_key[, encoding])",
              "type": "method",
              "name": "setPublicKey",
              "meta": {
                "added": [
                  "v0.11.14"
                ],
                "deprecated": [
                  "v5.2.0"
                ]
              },
              "stability": 0,
              "stabilityText": "Deprecated",
              "desc": "<p>Sets the EC Diffie-Hellman public key. Key encoding can be <code>&#39;latin1&#39;</code>,\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is provided <code>public_key</code> is expected to\nbe a string; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is expected.</p>\n<p>Note that there is not normally a reason to call this method because <code>ECDH</code>\nonly requires a private key and the other party&#39;s public key to compute the\nshared secret. Typically either <a href=\"#crypto_ecdh_generatekeys_encoding_format\"><code>ecdh.generateKeys()</code></a> or\n<a href=\"#crypto_ecdh_setprivatekey_private_key_encoding\"><code>ecdh.setPrivateKey()</code></a> will be called. The <a href=\"#crypto_ecdh_setprivatekey_private_key_encoding\"><code>ecdh.setPrivateKey()</code></a> method\nattempts to generate the public point/key associated with the private key being\nset.</p>\n<p>Example (obtaining a shared secret):</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst alice = crypto.createECDH(&#39;secp256k1&#39;);\nconst bob = crypto.createECDH(&#39;secp256k1&#39;);\n\n// Note: This is a shortcut way to specify one of Alice&#39;s previous private\n// keys. It would be unwise to use such a predictable private key in a real\n// application.\nalice.setPrivateKey(\n  crypto.createHash(&#39;sha256&#39;).update(&#39;alice&#39;, &#39;utf8&#39;).digest()\n);\n\n// Bob uses a newly generated cryptographically strong\n// pseudorandom key pair bob.generateKeys();\n\nconst alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\nconst bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\n\n// alice_secret and bob_secret should be the same shared secret value\nconsole.log(alice_secret === bob_secret);\n</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "meta": {
            "added": [
              "v0.1.92"
            ]
          },
          "desc": "<p>The <code>Hash</code> class is a utility for creating hash digests of data. It can be\nused in one of two ways:</p>\n<ul>\n<li>As a <a href=\"stream.html\">stream</a> that is both readable and writable, where data is written\nto produce a computed hash digest on the readable side, or</li>\n<li>Using the <a href=\"#crypto_hash_update_data_input_encoding\"><code>hash.update()</code></a> and <a href=\"#crypto_hash_digest_encoding\"><code>hash.digest()</code></a> methods to produce the\ncomputed hash.</li>\n</ul>\n<p>The <a href=\"#crypto_crypto_createhash_algorithm\"><code>crypto.createHash()</code></a> method is used to create <code>Hash</code> instances. <code>Hash</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Hash</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.on(&#39;readable&#39;, () =&gt; {\n  var data = hash.read();\n  if (data)\n    console.log(data.toString(&#39;hex&#39;));\n    // Prints:\n    //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n});\n\nhash.write(&#39;some data to hash&#39;);\nhash.end();\n</code></pre>\n<p>Example: Using <code>Hash</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\ninput.pipe(hash).pipe(process.stdout);\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_hash_update_data_input_encoding\"><code>hash.update()</code></a> and <a href=\"#crypto_hash_digest_encoding\"><code>hash.digest()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hash = crypto.createHash(&#39;sha256&#39;);\n\nhash.update(&#39;some data to hash&#39;);\nconsole.log(hash.digest(&#39;hex&#39;));\n// Prints:\n//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Calculates the digest of all of the data passed to be hashed (using the\n<a href=\"#crypto_hash_update_data_input_encoding\"><code>hash.update()</code></a> method). The <code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;latin1&#39;</code> or\n<code>&#39;base64&#39;</code>. If <code>encoding</code> is provided a string will be returned; otherwise\na <a href=\"buffer.html\"><code>Buffer</code></a> is returned.</p>\n<p>The <code>Hash</code> object can not be used again after <code>hash.digest()</code> method has been\ncalled. Multiple calls will cause an error to be thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Updates the hash content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;latin1&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a <a href=\"buffer.html\"><code>Buffer</code></a> then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "meta": {
            "added": [
              "v0.1.94"
            ]
          },
          "desc": "<p>The <code>Hmac</code> Class is a utility for creating cryptographic HMAC digests. It can\nbe used in one of two ways:</p>\n<ul>\n<li>As a <a href=\"stream.html\">stream</a> that is both readable and writable, where data is written\nto produce a computed HMAC digest on the readable side, or</li>\n<li>Using the <a href=\"#crypto_hmac_update_data_input_encoding\"><code>hmac.update()</code></a> and <a href=\"#crypto_hmac_digest_encoding\"><code>hmac.digest()</code></a> methods to produce the\ncomputed HMAC digest.</li>\n</ul>\n<p>The <a href=\"#crypto_crypto_createhmac_algorithm_key\"><code>crypto.createHmac()</code></a> method is used to create <code>Hmac</code> instances. <code>Hmac</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Hmac</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nhmac.on(&#39;readable&#39;, () =&gt; {\n  var data = hmac.read();\n  if (data)\n    console.log(data.toString(&#39;hex&#39;));\n    // Prints:\n    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n});\n\nhmac.write(&#39;some data to hash&#39;);\nhmac.end();\n</code></pre>\n<p>Example: Using <code>Hmac</code> and piped streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst fs = require(&#39;fs&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nconst input = fs.createReadStream(&#39;test.js&#39;);\ninput.pipe(hmac).pipe(process.stdout);\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_hmac_update_data_input_encoding\"><code>hmac.update()</code></a> and <a href=\"#crypto_hmac_digest_encoding\"><code>hmac.digest()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst hmac = crypto.createHmac(&#39;sha256&#39;, &#39;a secret&#39;);\n\nhmac.update(&#39;some data to hash&#39;);\nconsole.log(hmac.digest(&#39;hex&#39;));\n// Prints:\n//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Calculates the HMAC digest of all of the data passed using <a href=\"#crypto_hmac_update_data_input_encoding\"><code>hmac.update()</code></a>.\nThe <code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;latin1&#39;</code> or <code>&#39;base64&#39;</code>. If <code>encoding</code> is\nprovided a string is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is returned;</p>\n<p>The <code>Hmac</code> object can not be used again after <code>hmac.digest()</code> has been\ncalled. Multiple calls to <code>hmac.digest()</code> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.94"
                ]
              },
              "desc": "<p>Updates the <code>Hmac</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;latin1&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a <a href=\"buffer.html\"><code>Buffer</code></a> then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Sign",
          "type": "class",
          "name": "Sign",
          "meta": {
            "added": [
              "v0.1.92"
            ]
          },
          "desc": "<p>The <code>Sign</code> Class is a utility for generating signatures. It can be used in one\nof two ways:</p>\n<ul>\n<li>As a writable <a href=\"stream.html\">stream</a>, where data to be signed is written and the\n<a href=\"#crypto_sign_sign_private_key_output_format\"><code>sign.sign()</code></a> method is used to generate and return the signature, or</li>\n<li>Using the <a href=\"#crypto_sign_update_data_input_encoding\"><code>sign.update()</code></a> and <a href=\"#crypto_sign_sign_private_key_output_format\"><code>sign.sign()</code></a> methods to produce the\nsignature.</li>\n</ul>\n<p>The <a href=\"#crypto_crypto_createsign_algorithm\"><code>crypto.createSign()</code></a> method is used to create <code>Sign</code> instances. <code>Sign</code>\nobjects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Sign</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;RSA-SHA256&#39;);\n\nsign.write(&#39;some data to sign&#39;);\nsign.end();\n\nconst private_key = getPrivateKeySomehow();\nconsole.log(sign.sign(private_key, &#39;hex&#39;));\n// Prints: the calculated signature\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_sign_update_data_input_encoding\"><code>sign.update()</code></a> and <a href=\"#crypto_sign_sign_private_key_output_format\"><code>sign.sign()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;RSA-SHA256&#39;);\n\nsign.update(&#39;some data to sign&#39;);\n\nconst private_key = getPrivateKeySomehow();\nconsole.log(sign.sign(private_key, &#39;hex&#39;));\n// Prints: the calculated signature\n</code></pre>\n<p>A <code>Sign</code> instance can also be created by just passing in the digest\nalgorithm name, in which case OpenSSL will infer the full signature algorithm\nfrom the type of the PEM-formatted private key, including algorithms that\ndo not have directly exposed name constants, e.g. &#39;ecdsa-with-SHA256&#39;.</p>\n<p>Example: signing using ECDSA with SHA256</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst sign = crypto.createSign(&#39;sha256&#39;);\n\nsign.update(&#39;some data to sign&#39;);\n\nconst private_key = &#39;-----BEGIN EC PRIVATE KEY-----\\n&#39; +\n        &#39;MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\\n&#39; +\n        &#39;AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\\n&#39; +\n        &#39;pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\\n&#39; +\n        &#39;-----END EC PRIVATE KEY-----\\n&#39;;\n\nconsole.log(sign.sign(private_key).toString(&#39;hex&#39;));\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "sign.sign(private_key[, output_format])",
              "type": "method",
              "name": "sign",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Calculates the signature on all the data passed through using either\n<a href=\"#crypto_sign_update_data_input_encoding\"><code>sign.update()</code></a> or <a href=\"stream.html#stream_writable_write_chunk_encoding_callback\"><code>sign.write()</code></a>.</p>\n<p>The <code>private_key</code> argument can be an object or a string. If <code>private_key</code> is a\nstring, it is treated as a raw key with no passphrase. If <code>private_key</code> is an\nobject, it is interpreted as a hash containing two properties:</p>\n<ul>\n<li><code>key</code> : {String} - PEM encoded private key</li>\n<li><code>passphrase</code> : {String} - passphrase for the private key</li>\n</ul>\n<p>The <code>output_format</code> can specify one of <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If\n<code>output_format</code> is provided a string is returned; otherwise a <a href=\"buffer.html\"><code>Buffer</code></a> is\nreturned.</p>\n<p>The <code>Sign</code> object can not be again used after <code>sign.sign()</code> method has been\ncalled. Multiple calls to <code>sign.sign()</code> will result in an error being thrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sign.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Updates the <code>Sign</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;latin1&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a <a href=\"buffer.html\"><code>Buffer</code></a> then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "meta": {
            "added": [
              "v0.1.92"
            ]
          },
          "desc": "<p>The <code>Verify</code> class is a utility for verifying signatures. It can be used in one\nof two ways:</p>\n<ul>\n<li>As a writable <a href=\"stream.html\">stream</a> where written data is used to validate against the\nsupplied signature, or</li>\n<li>Using the <a href=\"#crypto_verifier_update_data_input_encoding\"><code>verify.update()</code></a> and <a href=\"#crypto_verifier_verify_object_signature_signature_format\"><code>verify.verify()</code></a> methods to verify\nthe signature.</li>\n</ul>\n<p>The [<code>crypto.createVerify()</code>][] method is used to create <code>Verify</code> instances.\n<code>Verify</code> objects are not to be created directly using the <code>new</code> keyword.</p>\n<p>Example: Using <code>Verify</code> objects as streams:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst verify = crypto.createVerify(&#39;RSA-SHA256&#39;);\n\nverify.write(&#39;some data to sign&#39;);\nverify.end();\n\nconst public_key = getPublicKeySomehow();\nconst signature = getSignatureToVerify();\nconsole.log(verify.verify(public_key, signature));\n// Prints: true or false\n</code></pre>\n<p>Example: Using the <a href=\"#crypto_verifier_update_data_input_encoding\"><code>verify.update()</code></a> and <a href=\"#crypto_verifier_verify_object_signature_signature_format\"><code>verify.verify()</code></a> methods:</p>\n<pre><code class=\"lang-js\">const crypto = require(&#39;crypto&#39;);\nconst verify = crypto.createVerify(&#39;RSA-SHA256&#39;);\n\nverify.update(&#39;some data to sign&#39;);\n\nconst public_key = getPublicKeySomehow();\nconst signature = getSignatureToVerify();\nconsole.log(verify.verify(public_key, signature));\n// Prints: true or false\n</code></pre>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data[, input_encoding])",
              "type": "method",
              "name": "update",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Updates the <code>Verify</code> content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\n<code>&#39;latin1&#39;</code>. If <code>encoding</code> is not provided, and the <code>data</code> is a string, an\nencoding of <code>&#39;utf8&#39;</code> is enforced. If <code>data</code> is a <a href=\"buffer.html\"><code>Buffer</code></a> then\n<code>input_encoding</code> is ignored.</p>\n<p>This can be called many times with new data as it is streamed.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature[, signature_format])",
              "type": "method",
              "name": "verify",
              "meta": {
                "added": [
                  "v0.1.92"
                ]
              },
              "desc": "<p>Verifies the provided data using the given <code>object</code> and <code>signature</code>.\nThe <code>object</code> argument is a string containing a PEM encoded object, which can be\none an RSA public key, a DSA public key, or an X.509 certificate.\nThe <code>signature</code> argument is the previously calculated signature for the data, in\nthe <code>signature_format</code> which can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>.\nIf a <code>signature_format</code> is specified, the <code>signature</code> is expected to be a\nstring; otherwise <code>signature</code> is expected to be a <a href=\"buffer.html\"><code>Buffer</code></a>.</p>\n<p>Returns <code>true</code> or <code>false</code> depending on the validity of the signature for\nthe data and public key.</p>\n<p>The <code>verifier</code> object can not be used again after <code>verify.verify()</code> has been\ncalled. Multiple calls to <code>verify.verify()</code> will result in an error being\nthrown.</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    }
  ]
}
